// -----------------------------------------------------------
// NDVI/EVI peaks, baseline deltas, + ADAPTIVE dynamic viability
// Single-AOI version (no ADM2_PCODE)
// Task name: seloi_craic_rice_agricultural_area
// -----------------------------------------------------------

// ===== AOI asset =====
var ASSET_ID = 
    'projects/ee-spenson/assets/food-security-timor-leste/seloi_craic_rice_agricultural_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/maliana_rice_agricultural_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/triloka_acid_soil_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/caibada_alkaline_soil_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/darasula_research_station_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/fatumaca_research_station_area'
//    'projects/ee-spenson/assets/food-security-timor-leste/natarbora_neutral_soil_area'
  ;
var REGION_NAME = ASSET_ID.split('/').pop();
var aoiFC  = ee.FeatureCollection(ASSET_ID);
var REGION = aoiFC.geometry().simplify(30);

// ===== Parameters =====
var START_YEAR      = 2019;
var END_YEAR        = 2025;
var BASELINE_YEARS  = [2019, 2020, 2021];
var YEARS           = ee.List.sequence(START_YEAR, END_YEAR);

var EXPORT_SCALE_M  = 20;         // export scale (m)
var CLD_PROB_THR    = 40;         // S2 cloud probability threshold (0..100)

// Adaptive viability percentile (per AOI, baseline-only)
var VIAB_PERCENTILE = 60;
var NDVI_CLAMP_MIN  = 0.35, NDVI_CLAMP_MAX = 0.55;
var EVI_CLAMP_MIN   = 0.30, EVI_CLAMP_MAX  = 0.50;

// “Greening” = positive anomaly vs baseline
var CHANGE_THR      = 0.01;       // Δ>0.01 ~ small but real increase
var PERSIST_MIN_YRS = 2;          // years required (of 2022–2025) for persistent greening

// ===== S2 preprocessing (join Harmonized S2_SR with s2cloudless; SCL + cloud prob masking) =====
var s2harmSR = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  .filterBounds(REGION)
  .filterDate(ee.Date.fromYMD(START_YEAR,1,1), ee.Date.fromYMD(END_YEAR,12,31).advance(1,'day'));

var s2cp = ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY')
  .filterBounds(REGION)
  .filterDate(ee.Date.fromYMD(START_YEAR,1,1), ee.Date.fromYMD(END_YEAR,12,31).advance(1,'day'));

// Join by granule id
var s2_joined = ee.ImageCollection(ee.Join.saveFirst('clouds').apply({
  primary: s2harmSR,
  secondary: s2cp,
  condition: ee.Filter.equals({
    leftField: 'system:index',
    rightField: 'system:index'
  })
}));

function addCloudProb(img) {
  var cld = ee.Image(img.get('clouds')).select('probability').rename('MSK_CLDPRB');
  return img.addBands(cld);
}

function maskS2(img) {
  var scl = img.select('SCL');
  var clearSCL  = scl.eq(4).or(scl.eq(5)).or(scl.eq(6)).or(scl.eq(11)); // veg, bare, water, snow/ice
  var clearProb = img.select('MSK_CLDPRB').lt(CLD_PROB_THR);
  return img.updateMask(clearSCL).updateMask(clearProb);
}

// Final S2 collection used downstream
var s2 = s2_joined
  .map(addCloudProb)
  .select(['B8','B4','B2','SCL','MSK_CLDPRB'])
  .map(maskS2);

// ===== Indices (surface reflectance scaling) =====
function ndviFrom(img) {
  var nir = img.select('B8').multiply(0.0001);
  var red = img.select('B4').multiply(0.0001);
  return nir.subtract(red).divide(nir.add(red)).rename('NDVI');
}
function eviFrom(img) {
  var nir  = img.select('B8').multiply(0.0001);
  var red  = img.select('B4').multiply(0.0001);
  var blue = img.select('B2').multiply(0.0001);
  return nir.subtract(red).multiply(2.5)
            .divide(nir.add(red.multiply(6)).subtract(blue.multiply(7.5)).add(1))
            .rename('EVI');
}
function yearCol(y, geom) {
  var start = ee.Date.fromYMD(y, 1, 1);
  var end   = start.advance(1, 'year');
  return s2.filterDate(start, end).filterBounds(geom);
}

// ===== Build multiband export image for the AOI =====
function buildExportImageForAOI(geom) {

  // --- Step 1: per-year peaks & counts (masked)
  var yearlyPeakIC = ee.ImageCollection(
    YEARS.map(function(y) {
      y = ee.Number(y);
      var col  = yearCol(y, geom);
      var ndIC = col.map(ndviFrom);
      var evIC = col.map(eviFrom);
      var ndPeak = ndIC.max().rename('NDVIp');
      var evPeak = evIC.max().rename('EVIp');
      var cnt    = ndIC.count().rename('CNT');
      var idx = ee.String('Y').cat(ee.Number(y).format('%.0f'));
      return ee.Image.cat(ndPeak, evPeak, cnt)
        .set('year', y)
        .set('system:index', idx)
        .set('system:time_start', ee.Date.fromYMD(y,1,1).millis())
        .clip(geom);
    })
  );

  // --- Step 2: BASELINE images & adaptive viability thresholds (per AOI)
  var baseIC        = yearlyPeakIC.filter(ee.Filter.inList('year', BASELINE_YEARS));
  var maxNDVI_base  = baseIC.select('NDVIp').max();
  var maxEVI_base   = baseIC.select('EVIp').max();

  // Safe percentile reduction with fallback + clamps
  var p        = VIAB_PERCENTILE;
  var pReducer = ee.Reducer.percentile([p]);

  var ndviDict = maxNDVI_base.reduceRegion({
    reducer: pReducer, geometry: geom, scale: 20, maxPixels: 1e13, bestEffort: true, tileScale: 4
  });
  var eviDict  = maxEVI_base.reduceRegion({
    reducer: pReducer, geometry: geom, scale: 20, maxPixels: 1e13, bestEffort: true, tileScale: 4
  });

  var ndviBand = ee.String(maxNDVI_base.bandNames().get(0));  // 'NDVIp'
  var eviBand  = ee.String(maxEVI_base.bandNames().get(0));   // 'EVIp'
  var pStr     = ee.Number(p).format('%.0f');
  var ndviKey  = ndviBand.cat('_p').cat(pStr);
  var eviKey   = eviBand .cat('_p').cat(pStr);

  var ndviThr0 = ee.Algorithms.If(ee.Dictionary(ndviDict).contains(ndviKey),
                                  ee.Dictionary(ndviDict).get(ndviKey), NDVI_CLAMP_MIN);
  var eviThr0  = ee.Algorithms.If(ee.Dictionary(eviDict).contains(eviKey),
                                  ee.Dictionary(eviDict).get(eviKey), EVI_CLAMP_MIN);

  var ndviThr = ee.Number(ndviThr0).max(NDVI_CLAMP_MIN).min(NDVI_CLAMP_MAX);
  var eviThr  = ee.Number(eviThr0 ).max(EVI_CLAMP_MIN ).min(EVI_CLAMP_MAX );

  // --- Step 3: DYNAMIC VIABILITY MASK (baseline-only, adaptive)
  var polyMask   = ee.Image().byte().paint(aoiFC, 1).selfMask();
  var viableMask = maxNDVI_base.gte(ndviThr).or(maxEVI_base.gte(eviThr));
  var cropMask   = polyMask.updateMask(viableMask).rename('VIABLE_MASK');

  // --- Step 4: Baselines (mean peaks over 2019–2021)
  var ndviBase = baseIC.select('NDVIp').mean().rename('NDVIp_base').toFloat();
  var eviBase  = baseIC.select('EVIp').mean().rename('EVIp_base').toFloat();

  // --- Step 5: Deltas vs baseline (per year)
  var deltaIC = yearlyPeakIC.map(function(img) {
    var dNdvi = img.select('NDVIp').subtract(ndviBase).rename('dNDVI');
    var dEvi  = img.select('EVIp').subtract(eviBase).rename('dEVI');
    return ee.Image.cat(dNdvi, dEvi).set('system:index', img.get('system:index'));
  });

  // --- Step 6: Stacks (masked to dynamic viable cropland)
  var ndviPeakBands = yearlyPeakIC.select('NDVIp').toBands().updateMask(cropMask).toFloat();
  var eviPeakBands  = yearlyPeakIC.select('EVIp').toBands().updateMask(cropMask).toFloat();
  var cntBands      = yearlyPeakIC.select('CNT').toBands().updateMask(cropMask).toFloat();
  var dNdviBands    = deltaIC.select('dNDVI').toBands().updateMask(cropMask).toFloat();
  var dEviBands     = deltaIC.select('dEVI').toBands().updateMask(cropMask).toFloat();

  // --- Step 7: Greening masks = INCREASE ONLY
  function greenYear_any(y) {
    var ys = 'Y' + y;
    var inc = dEviBands.select(ys + '_dEVI').gt(CHANGE_THR)
               .or(dNdviBands.select(ys + '_dNDVI').gt(CHANGE_THR));
    return inc.updateMask(cropMask).rename(ys + '_GREEN_inc_any').toFloat();
  }
  function greenYear_both(y) {
    var ys = 'Y' + y;
    var inc = dEviBands.select(ys + '_dEVI').gt(CHANGE_THR)
               .and(dNdviBands.select(ys + '_dNDVI').gt(CHANGE_THR));
    return inc.updateMask(cropMask).rename(ys + '_GREEN_inc_both').toFloat();
  }

  var g22_any = greenYear_any(2022), g23_any = greenYear_any(2023),
      g24_any = greenYear_any(2024), g25_any = greenYear_any(2025);

  var g22_both = greenYear_both(2022), g23_both = greenYear_both(2023),
      g24_both = greenYear_both(2024), g25_both = greenYear_both(2025);

  var any_any     = g22_any.add(g23_any).add(g24_any).add(g25_any)
                     .gt(0).rename('GREEN_any_2022_2025_inc_any').toFloat();
  var persist_any = g22_any.add(g23_any).add(g24_any).add(g25_any)
                     .gte(PERSIST_MIN_YRS).rename('GREEN_persist_ge2_2022_2025_inc_any').toFloat();

  var any_both     = g22_both.add(g23_both).add(g24_both).add(g25_both)
                      .gt(0).rename('GREEN_any_2022_2025_inc_both').toFloat();
  var persist_both = g22_both.add(g23_both).add(g24_both).add(g25_both)
                      .gte(PERSIST_MIN_YRS).rename('GREEN_persist_ge2_2022_2025_inc_both').toFloat();

  var masks = ee.Image.cat([
    cropMask,                          // VIABLE_MASK
    g22_any, g23_any, g24_any, g25_any,
    g22_both, g23_both, g24_both, g25_both,
    any_any,  persist_any,
    any_both, persist_both
  ]).toFloat();

  // --- Step 8: Final multiband image
  return ee.Image.cat(
           ndviPeakBands, eviPeakBands, cntBands,
           ndviBase, eviBase,
           dNdviBands, dEviBands,
           masks
         ).clip(geom).toFloat();
}

// ===== Build & export (single task) =====
var outImg = buildExportImageForAOI(REGION);

Export.image.toDrive({
  image:          outImg,
  description:    REGION_NAME,
  fileNamePrefix: REGION_NAME + '_NDVI_EVI_GREEN_INCREASE_2019_2025_20m',
  folder:         'NDVI_Change_TIMOR_ADM2',
  region:         REGION,
  scale:          EXPORT_SCALE_M,
  maxPixels:      1e13
});

// Map cues
Map.centerObject(aoiFC, 13);
Map.addLayer(aoiFC, {color: 'yellow'}, 'AOI');
