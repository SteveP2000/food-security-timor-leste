// -----------------------------------------------------------
// NDVI peaks, baseline deltas, + ADAPTIVE dynamic viability (NDVI-only)
// Memory-lean OPTION A (single export per ADM2):
//  - Cloudiness prefilter on S2_SR_HARMONIZED
//  - Smaller percentile sampling & tileScale
//  - Stronger geometry simplification
//  - ONE GeoTIFF per ADM2 with COG + tiled writing (fileDimensions)
//  - All bands cast to Float32 to avoid dtype-mismatch export errors
// -----------------------------------------------------------

var adm2FC = ee.FeatureCollection(
  'projects/ee-spenson/assets/food-security-timor-leste/LULC_Mean_Probability_Harvest_cropland_mask_adm2_v2'
//  'projects/ee-spenson/assets/food-security-timor-leste/LULC_Impact_Observatory_cropland_mask_adm2'  
);

// ===== Parameters =====
var START_YEAR      = 2019;
var END_YEAR        = 2025;
var BASELINE_YEARS  = [2019, 2020, 2021];
var YEARS           = ee.List.sequence(START_YEAR, END_YEAR);

var EXPORT_SCALE_M  = 20;   // export scale (m)
var CLD_PROB_THR    = 40;   // s2cloudless prob threshold (0..100)

// Viability percentile (per ADM2, baseline-only)
var VIAB_PERCENTILE = 60;   // raise to 65–70 if you want stricter viability
var NDVI_CLAMP_MIN  = 0.35, NDVI_CLAMP_MAX = 0.55;

// Δ detection parameters (σ-based)
var K_SIGMA         = 1.0;  // try 1.0–1.5
var DELTA_FLOOR     = 0.01; // floor to suppress tiny numeric noise

// Observation gating
var MIN_CNT         = 6;    // min clear observations per year to accept a peak

var BATCH_SIZE      = 25;   // task batching

// Percentile sampling knobs (leaner)
var PCTL_SAMPLE_SCALE = 50;     // 40–60 m
var PCTL_NUMPIXELS    = 20000;  // smaller sample = less memory
var PCTL_TILESCALE    = 2;      // lower tileScale => lower per-tile memory

// ===== S2 preprocessing: HARMONIZED SR + robust inner join to s2cloudless =====
var fullGeom = adm2FC.geometry();

var s2harm = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  .filterBounds(fullGeom)
  .filterDate(ee.Date.fromYMD(START_YEAR,1,1), ee.Date.fromYMD(END_YEAR,12,31).advance(1,'day'))
  // Cloudiness prefilter removes hopeless scenes before pixel masking:
  .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 80));

var s2cp  = ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY')
  .filterBounds(fullGeom)
  .filterDate(ee.Date.fromYMD(START_YEAR,1,1), ee.Date.fromYMD(END_YEAR,12,31).advance(1,'day'));

// Inner join ensures every kept S2 scene has a matching cloud-probability granule
var innerJoined = ee.Join.inner().apply({
  primary: s2harm,
  secondary: s2cp,
  condition: ee.Filter.equals({ leftField: 'system:index', rightField: 'system:index' })
});

// Attach MSK_CLDPRB as a band
var s2_withCP = ee.ImageCollection(innerJoined.map(function (pair) {
  var s2 = ee.Image(pair.get('primary'));
  var cp = ee.Image(pair.get('secondary')).select('probability').rename('MSK_CLDPRB');
  return s2.addBands(cp);
}));

function maskS2(img) {
  var scl = img.select('SCL');
  var clearSCL  = scl.eq(4).or(scl.eq(5)).or(scl.eq(6)).or(scl.eq(11)); // veg, bare, water, snow/ice
  var clearProb = img.select('MSK_CLDPRB').lt(CLD_PROB_THR);
  return img.updateMask(clearSCL).updateMask(clearProb);
}

// ----- Precompute NDVI once (post-mask) -----
function addNDVI(img){
  var nir  = img.select('B8').multiply(0.0001);
  var red  = img.select('B4').multiply(0.0001);
  var ndvi = nir.subtract(red).divide(nir.add(red)).rename('NDVI');
  return img.addBands(ndvi);
}

// Final collection used downstream: masked S2 → add NDVI
var s2I = s2_withCP
  .select(['B8','B4','SCL','MSK_CLDPRB'])
  .map(maskS2)
  .map(addNDVI);

// ===== Helpers =====
function cleanGeom(g) {
  // Non-zero error margin + stronger simplify to reduce topology complexity
  return ee.Geometry(g).buffer(0, 1).simplify(60);
}

function yearCol(y, geom) {
  var start = ee.Date.fromYMD(y, 1, 1);
  var end   = start.advance(1, 'year');
  var GG    = cleanGeom(geom);
  // Clip early to cut work and avoid projection issues at boundaries
  return s2I.filterDate(start, end).filterBounds(GG)
            .map(function(img){ return img.clip(GG); });
}

function safeName(str, maxLen) {
  str = (str || '').toString().replace(/[^A-Za-z0-9_-]/g, '_');
  return (str.length > maxLen) ? str.slice(0, maxLen) : str;
}

// Safe constructors for yearly peaks/counts when a year has zero valid scenes
function safeMaxBand(ic, band, outName){
  var has = ic.size().gt(0);
  return ee.Image(ee.Algorithms.If(
    has, ic.select(band).max().rename(outName),
    ee.Image.constant(0).rename(outName).updateMask(ee.Image(0)) // fully masked placeholder
  ));
}
function safeCountBand(ic, band, outName){
  var has = ic.size().gt(0);
  return ee.Image(ee.Algorithms.If(
    has, ic.select(band).count().rename(outName),
    ee.Image.constant(0).rename(outName) // 0 is fine for counts
  ));
}

// --- SAMPLE-BASED percentile over a region (lightweight & robust) ---
// Checks both 'pXX' (sample reduceColumns) and 'band_pXX' (reduceRegion-style) keys.
function regionPercentile(img, region, p, sampScale, numPix, tileScale) {
  var band = ee.String(img.bandNames().get(0)); // e.g., 'NDVIp'
  var GG   = cleanGeom(region);

  var samp = img.sample({
    region: GG,
    scale:  sampScale,
    numPixels: numPix,
    seed: 1,
    geometries: false,
    tileScale: tileScale
  });

  var hasSamples = samp.size().gt(0);
  var rawDict = ee.Algorithms.If(
    hasSamples,
    samp.reduceColumns(ee.Reducer.percentile([p]), [band]),
    ee.Dictionary({})
  );
  var dict   = ee.Dictionary(rawDict);
  var key1   = ee.String('p').cat(ee.Number(p).format('%.0f'));      // preferred for sample reduceColumns
  var key2   = band.cat('_p').cat(ee.Number(p).format('%.0f'));      // fallback if server returns band_pXX
  var val    = ee.Algorithms.If(dict.contains(key1), dict.get(key1),
                ee.Algorithms.If(dict.contains(key2), dict.get(key2), null));
  return val; // may be null
}

// ===== Build multiband image for one ADM2 (robust baseline + σ-thresholds) =====
function buildExportImageForADM2(adm2_code) {
  var subset = adm2FC.filter(ee.Filter.eq('ADM2_PCODE', adm2_code));
  var region = cleanGeom(ee.Feature(subset.first()).geometry());

  // --- Step 1: per-year NDVI peaks & counts (using precomputed NDVI)
  var yearlyPeakIC = ee.ImageCollection(
    YEARS.map(function(y) {
      y = ee.Number(y);
      var col    = yearCol(y, region);
      var ndPeak = safeMaxBand(col, 'NDVI', 'NDVIp');
      var cnt    = safeCountBand(col, 'NDVI', 'CNT'); // per-pixel # of clear samples
      var idx    = ee.String('Y').cat(ee.Number(y).format('%.0f'));
      return ee.Image.cat(ndPeak, cnt)
        .set('year', y)
        .set('system:index', idx)
        .set('system:time_start', ee.Date.fromYMD(y,1,1).millis())
        .clip(region);
    })
  );

  // --- Step 2: BASELINE images & adaptive viability thresholds (per ADM2)
  var baseIC        = yearlyPeakIC.filter(ee.Filter.inList('year', BASELINE_YEARS));
  var maxNDVI_base  = baseIC.select('NDVIp').max();

  // Sample-based percentile (lean)
  var pVal = regionPercentile(maxNDVI_base, region, VIAB_PERCENTILE,
                              PCTL_SAMPLE_SCALE, PCTL_NUMPIXELS, PCTL_TILESCALE);
  var ndviThr0 = ee.Algorithms.If(pVal, pVal, NDVI_CLAMP_MIN);
  var ndviThr  = ee.Number(ndviThr0).max(NDVI_CLAMP_MIN).min(NDVI_CLAMP_MAX);

  // --- Step 3: DYNAMIC VIABILITY MASK (baseline-only, NDVI-only)
  var polyMask   = ee.Image().byte().paint(subset, 1).selfMask();
  var viableMask = maxNDVI_base.gte(ndviThr);
  var cropMask   = polyMask.updateMask(viableMask).rename('VIABLE_MASK'); // Byte internally

  // --- Step 4: Robust BASELINE = MEDIAN of NDVI peaks over 2019–2021
  var ndviBase = baseIC.select('NDVIp').median().rename('NDVIp_base'); // Float32 later

  // Baseline variability (σ) for σ-based Δ thresholds with safe fallback
  var ndSigma   = baseIC.select('NDVIp').reduce(ee.Reducer.stdDev()).rename('NDVIp_sd');
  var ndThrImg  = ndSigma.multiply(K_SIGMA).where(ndSigma.lte(0), DELTA_FLOOR).max(DELTA_FLOOR);

  // --- Step 5: Deltas vs median baseline (per year)
  var deltaIC = yearlyPeakIC.map(function(img) {
    var dNdvi = img.select('NDVIp').subtract(ndviBase).rename('dNDVI'); // Float32 later
    return ee.Image.cat(dNdvi, img.select('CNT')).set('system:index', img.get('system:index'));
  });

  // --- Step 6: Stacks (masked to dynamic viable cropland)
  var ndviPeakBands = yearlyPeakIC.select('NDVIp').toBands().updateMask(cropMask);
  var cntBands      = yearlyPeakIC.select('CNT'  ).toBands().updateMask(cropMask);
  var dNdviBands    = deltaIC     .select('dNDVI').toBands().updateMask(cropMask);

  // --- Step 7: Greening masks = INCREASE ONLY (NDVI) with σ-thresholds + MIN_CNT gating
  function greenYear_ndvi(y) {
    var ys   = 'Y' + y;
    var cntOk = cntBands.select(ys + '_CNT').gte(MIN_CNT);
    var inc  = dNdviBands.select(ys + '_dNDVI').gt(ndThrImg).and(cntOk);
    return inc.updateMask(cropMask).rename(ys + '_GREEN_inc_ndvi');
  }

  var g22 = greenYear_ndvi(2022), g23 = greenYear_ndvi(2023),
      g24 = greenYear_ndvi(2024), g25 = greenYear_ndvi(2025);

  var any_ndvi     = g22.add(g23).add(g24).add(g25).gt(0).rename('GREEN_any_2022_2025_inc_ndvi');
  var persist_ndvi = g22.add(g23).add(g24).add(g25).gte(2).rename('GREEN_persist_ge2_2022_2025_inc_ndvi');

  // --- Step 8: Final multiband image — cast ALL to Float32 to ensure compatible dtypes
  var outImg = ee.Image.cat(
                 ndviPeakBands,        // per-year NDVI peaks
                 cntBands,             // per-year counts
                 ndviBase,             // baseline median
                 dNdviBands,           // per-year deltas
                 ee.Image(cropMask).rename('VIABLE_MASK'), // mask
                 ee.Image.cat([g22, g23, g24, g25, any_ndvi, persist_ndvi])
               ).toFloat()             // <-- enforce uniform dtype
               .clip(region);

  return outImg;
}

// ===== Queue tasks (batched) =====
adm2FC.aggregate_array('ADM2_PCODE').evaluate(function(codes) {
  if (!codes || !codes.length) { print('No ADM2_PCODE values found.'); return; }
  print('Preparing', codes.length, 'ADM2 exports… Open the Tasks tab.');

  for (var i = 0; i < codes.length; i += BATCH_SIZE) {
    var batch = codes.slice(i, Math.min(i + BATCH_SIZE, codes.length));
    batch.forEach(function(codeRaw) {
      var code   = safeName(codeRaw, 40);
      var desc   = safeName('NDVI_GREEN_INCREASE_' + code, 60);
      var fn     = safeName(code + '_NDVI_GREEN_INCREASE_2019_2025_20m', 80);

      var feat   = adm2FC.filter(ee.Filter.eq('ADM2_PCODE', codeRaw)).first();
      var region = cleanGeom(ee.Feature(feat).geometry());

      var outImg = buildExportImageForADM2(codeRaw);

      // --- Export to Drive (single tiled GeoTIFF, COG)
      Export.image.toDrive({
        image:          outImg,
        description:    desc,
        fileNamePrefix: fn,
        folder:         'NDVI_Change_TIMOR_ADM2',
        region:         region,
        scale:          EXPORT_SCALE_M,
        maxPixels:      1e13,
        fileFormat:     'GeoTIFF',
        fileDimensions: 8192,              // tile the output to reduce memory
        skipEmptyTiles: true,              // don’t write fully masked tiles
        formatOptions:  { cloudOptimized: true } // write a COG
      });
    });
    print('Queued batch', (i / BATCH_SIZE) + 1, 'with', batch.length, 'tasks.');
  }
});
